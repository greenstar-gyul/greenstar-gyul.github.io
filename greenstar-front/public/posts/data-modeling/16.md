# 🟡 데이터 모델링 - (3)

## ✅ 정규화(Normalization)란?

> **중복을 제거**하고, **구조를 단순화**하여
> 데이터의 **일관성과 무결성**을 유지하기 위한 **테이블 분해 과정**!

### 왜 정규화가 필요할까?

| 이유                   | 설명                           |
| -------------------- | ---------------------------- |
| ✅ **데이터 중복 방지**      | 같은 정보가 여러 곳에 있으면 수정 시 일관성 깨짐 |
| ✅ **삽입·삭제·갱신 이상 방지** | 비정상적인 데이터 조작 상황(이상 현상) 예방    |
| ✅ **논리적 구조의 단순화**    | 데이터 구조가 더 명확해지고, 유지보수 쉬움     |

---

## 📌 관계 스키마(Relation Schema)

* 테이블 구조를 정의한 것
* **릴레이션의 이름**과 **속성들의 집합**으로 구성됨
  → 예: `STUDENT(학번, 이름, 전공, 학과전화번호)`

---

## ⚠️ 이상(Anomaly) 현상

> 정규화가 제대로 되지 않았을 때 발생하는 문제

| 종류        | 설명                        | 예시                             |
| --------- | ------------------------- | ------------------------------ |
| **삽입 이상** | 일부 정보를 넣기 어려움             | 새 학생 등록 시, 아직 수강 과목이 없어서 등록 불가 |
| **삭제 이상** | 일부 정보가 함께 삭제됨             | 수강 정보 삭제 시, 학생 정보까지 삭제됨        |
| **갱신 이상** | 같은 정보가 여러 곳에 있어 모두 수정해야 함 | 전공명 바뀔 때, 여러 행 모두 수정해야 함       |

---

## ✅ 함수적 종속(Functional Dependency)

> 어떤 속성 A가 주어지면, 다른 속성 B의 값이 **항상 유일하게 결정되는 관계**
> → A → B (A가 B를 함수적으로 결정한다)

🔍 예시:

> 학번 → 이름, 전공
> 즉, 학번이 주어지면 이름과 전공은 **하나로 정해진다**.

---

## 🔷 정규형(Normal Form)

> 릴레이션이 어떤 정규화 수준을 만족하는지 나타낸 것
> → 제1정규형(1NF)부터 제5정규형(5NF)까지 존재

---

## ✅ 제1 정규형 (1NF: First Normal Form)

### 🔹 핵심 조건: **속성값은 반드시 원자값(Atomic value)**

* 원자값이란? → **쪼갤 수 없는 단일 값**
* 리스트, 쉼표 구분된 문자열, 복합 구조는 ✖️

#### ❌ 예시 (비정규형)

| 학번   | 이름  | 전화번호               |
| ---- | --- | ------------------ |
| 1001 | 홍길동 | 010-1234, 010-5678 |

#### ✅ 해결 방법

* 전화번호를 분리해서 각각의 행으로 만들거나, 새로운 테이블로!

| 학번   | 이름  | 전화번호          |
| ---- | --- | ------------- |
| 1001 | 홍길동 | 010-1234-5678 |
| 1001 | 홍길동 | 010-5678-1234 |

---

## ✅ 제2 정규형 (2NF: Second Normal Form)

### 🔹 핵심 조건:

1. **1NF 만족**
2. **부분 함수 종속 제거**

---

### 📘 부분 함수 종속이란?

> 복합 기본키의 **일부분에만 종속된 속성**

#### ❌ 예시

| 학번   | 과목코드  | 과목명  | 점수 |
| ---- | ----- | ---- | -- |
| 1001 | CS101 | DB개론 | 85 |

* 기본키 = (학번, 과목코드)
* `과목명`은 **과목코드**만 알면 결정됨 → 부분 종속

---

#### ✅ 해결 방법

→ 테이블 분리!

* `수강(학번, 과목코드, 점수)`
* `과목(과목코드, 과목명)`

---

## ✅ 제3 정규형 (3NF: Third Normal Form)

### 🔹 핵심 조건:

1. **2NF 만족**
2. **이행 함수 종속 제거**

---

### 📘 이행 함수 종속이란?

> A → B, B → C 라면 A → C 되는 관계
> → 즉, **기본키가 아닌 속성이 또 다른 속성을 결정**

---

#### ❌ 예시

| 학번   | 학과코드 | 학과명   |
| ---- | ---- | ----- |
| 1001 | CS   | 컴퓨터공학 |

* `학번 → 학과코드`
* `학과코드 → 학과명`
* 따라서 `학번 → 학과명` (이행 종속!)

---

#### ✅ 해결 방법

→ `학생(학번, 학과코드)`
→ `학과(학과코드, 학과명)`으로 분리

---

## ✅ BCNF (Boyce–Codd Normal Form)

### 🔹 핵심 조건:

* 3NF 만족 + 모든 결정자는 **후보키**여야 함

---

### 📘 왜 3NF보다 더 엄격할까?

> 어떤 속성이 **후보키가 아닌데 다른 속성을 결정**하는 경우 존재할 수 있음

#### ❌ 예시

| 교수명 | 과목명  | 강의실  |
| --- | ---- | ---- |
| 김교수 | DB개론 | 101호 |

* 한 교수는 한 강의실에서만 수업함 → `교수명 → 강의실` (결정자)
* 하나의 과목은 여러 교수가 가르칠 수 있음
* (교수명, 과목명)만이 후보키인데, **교수명만으로 결정**

→ `교수(교수명, 강의실)`
→ `강의(교수명, 과목명)` 으로 분리해야 함

---

## ✅ 제4 정규형 (4NF: Fourth Normal Form)

### 🔹 핵심 조건:

* **다치 종속(Multivalued Dependency)** 제거

---

### 📘 다치 종속이란?

> A →→ B, A →→ C (B와 C는 서로 독립적)

즉, 하나의 값에 대해 **여러 개의 값이 종속되며, 서로 독립**일 때

---

#### ❌ 예시

| 이름 | 취미     | 자격증          |
| -- | ------ | ------------ |
| 민수 | 등산, 독서 | 정보처리기사, 운전면허 |

* 민수는 **2개의 취미**와 **2개의 자격증** → 조합이 2x2 = 4개가 생김

→ `취미`와 `자격증`은 서로 관련 없는 **독립적인 다치 종속**

---

#### ✅ 해결 방법

→ 분리!

* `취미(이름, 취미)`
* `자격증(이름, 자격증)`

---

## ✅ 제5 정규형 (5NF: Fifth Normal Form)

### 🔹 핵심 조건:

* **조인 종속(Join Dependency)** 제거

---

### 📘 조인 종속이란?

> 어떤 릴레이션이 **분해되었다가 다시 조인되었을 때**,
> 원래 릴레이션과 같아야 한다는 조건이 **항상 성립하지 않는 경우**

---

#### ❌ 예시

| 학생 | 강좌 | 교수  |
| -- | -- | --- |
| A  | 수학 | 김교수 |
| A  | 과학 | 이교수 |

* 이 조합은
  (학생, 강좌), (학생, 교수), (강좌, 교수) 테이블로 나눌 수 있음
  → 그런데 이걸 다시 조인할 때 **의도하지 않은 조합**이 생길 수 있음

→ 매우 복잡한 구조이며, 대부분의 실제 프로젝트에서는 **5NF까지 적용 안 함**

---

## 📌 종속성 요약 정리

| 종속성 종류    | 설명                          | 예시                   |
| --------- | --------------------------- | -------------------- |
| **함수 종속** | A → B                       | 학번 → 이름              |
| **부분 종속** | 기본키의 일부 → 속성                | 과목코드 → 과목명 (복합키 일부)  |
| **이행 종속** | A → B, B → C → A → C        | 학번 → 학과코드 → 학과명      |
| **다치 종속** | A →→ B, A →→ C (B ⊥ C)      | 이름 →→ 취미 / 이름 →→ 자격증 |
| **조인 종속** | 분해된 릴레이션을 조인했을 때 원래와 다르면 문제 | 학생–강좌–교수 조합          |

---

맞아! 아주 중요한 포인트를 짚었어.
**정규화는 데이터 무결성과 구조 명확성을 위해 꼭 필요하지만**,
모든 상황에서 무조건 정규화를 따르는 게 능사는 아니야.
그래서 **마지막 단락에 "정규화의 한계와 유의점"** 섹션을 아래처럼 추가할 수 있어:

---

## ⚠️ 정규화의 한계와 유의점

정규화는 분명 강력한 원칙이지만, **실무에서는 무조건적인 정규화가 오히려 비효율**이 될 수 있어요.

---

### 🧱 1. 너무 많은 테이블 분해 → **JOIN 남발**

* 정규화가 진행될수록 **데이터를 나눠야 할 테이블 수가 증가**
* 그러면 하나의 데이터를 조회하기 위해 여러 테이블을 **조인(JOIN)** 해야 함
* **조인 비용이 커지면 성능 저하 발생**

---

### 💾 2. 성능 vs 무결성: **균형이 중요**

* 조회가 많은 시스템 (예: 블로그, 커머스)에서는 \*\*반정규화(De-normalization)\*\*를 일부러 적용하기도 해
* 예를 들어, 자주 조인되는 테이블을 미리 하나로 합쳐놓는 식

---

### 🛠️ 3. **반정규화도 전략**

| 상황    | 고려할 수 있는 반정규화             |
| ----- | ------------------------- |
| 속도 중요 | 자주 조회하는 정보를 미리 계산해서 저장    |
| 조인 과다 | 자주 함께 쓰이는 테이블을 병합         |
| 통계/집계 | 통계값을 실시간 계산 대신 별도 저장소에 캐싱 |

---

### ✅ 결론: “정규화는 기본, 실무에선 유연하게”

* 정규화는 **데이터 구조의 기본 설계 원칙**
* 하지만 실무에서는 **읽기/쓰기 빈도**, **쿼리 패턴**, **성능 요구사항**에 따라 조절해야 해
* 즉, \*\*“정규화는 기본, 반정규화는 전략”\*\*이란 마인드가 중요해요 😊

---

## 🧠 전체 흐름 요약

```text
1NF → 원자값
  ↓
2NF → 부분 종속 제거
  ↓
3NF → 이행 종속 제거
  ↓
BCNF → 모든 결정자는 후보키
  ↓
4NF → 다치 종속 제거
  ↓
5NF → 조인 종속 제거
```

---

## 📚 참고자료

* 『데이터 모델링』 강의 자료
* ChatGPT(OpenAI) 설명 도움

> 이 글은 글쓴이의 실습과 개념 정리를 바탕으로, ChatGPT의 도움을 받아
> **데이터 정규화에 대한 개념을 명확하게 전달**하기 위해 작성된 학습 자료입니다. 😊
