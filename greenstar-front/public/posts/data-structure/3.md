블로그 글을 확인해 봤어. 정말 기본적인 내용만 담겨 있네! 스택이라는 중요한 자료구조에 대해 더 풍부한 내용으로 보충해 줄게.

# 스택(Stack) 자료구조 완전 정복

## 목차
1. [스택의 개념](#스택의-개념)
2. [스택의 주요 특징](#스택의-주요-특징)
3. [스택의 기본 연산](#스택의-기본-연산)
4. [스택의 구현 방법](#스택의-구현-방법)
5. [스택의 활용 사례](#스택의-활용-사례)
6. [자바스크립트로 스택 구현](#자바스크립트로-스택-구현)
7. [스택 관련 주요 알고리즘 문제](#스택-관련-주요-알고리즘-문제)
8. [스택과 메모리](#스택과-메모리)
9. [면접에서 자주 나오는 스택 관련 질문](#면접에서-자주-나오는-스택-관련-질문)

## 스택의 개념

스택(Stack)은 **후입선출(LIFO, Last-In-First-Out)** 원칙을 따르는 선형 자료구조입니다. 이름 그대로 물건을 '쌓는다'는 의미가 있으며, 데이터를 차곡차곡 쌓고 가장 최근에 추가된 데이터부터 접근할 수 있습니다.

책상 위에 책을 쌓는 것을 상상해보세요. 새로운 책은 항상 맨 위에 올려지고, 책을 꺼낼 때도 맨 위에 있는 책부터 꺼내게 됩니다. 스택이 바로 이런 방식으로 작동합니다.

## 스택의 주요 특징

1. **후입선출(LIFO) 구조**
   - 가장 나중에 들어온 데이터가 가장 먼저 나가는 구조
   - 입구와 출구가 동일한 한쪽 끝에서만 접근 가능

2. **제한적인 접근**
   - 스택의 top(맨 위)에서만 데이터 접근, 삽입, 삭제가 가능
   - 중간에 있는 데이터에 직접 접근할 수 없음

3. **순서 보존**
   - 데이터의 삽입 순서가 그대로 보존됨 (역순으로 꺼낼 수 있음)
   - 이력 추적이나 되돌리기 기능에 적합

4. **단순하고 효율적인 구조**
   - 구현이 간단하고 메모리 사용이 효율적
   - 대부분의 연산이 O(1) 시간 복잡도를 가짐

## 스택의 기본 연산

스택은 다음과 같은 기본 연산을 제공합니다:

1. **push(item)**: 스택의 맨 위에 새로운 항목을 추가
   ```
   top ← top + 1
   stack[top] ← item
   ```

2. **pop()**: 스택의 맨 위 항목을 제거하고 반환
   ```
   if isEmpty() then
       return "스택 언더플로우"
   item ← stack[top]
   top ← top - 1
   return item
   ```

3. **peek() / top()**: 스택의 맨 위 항목을 제거하지 않고 반환
   ```
   if isEmpty() then
       return "스택이 비었습니다"
   return stack[top]
   ```

4. **isEmpty()**: 스택이 비어있는지 확인
   ```
   return (top < 0)
   ```

5. **size()**: 스택에 저장된 항목의 개수를 반환
   ```
   return top + 1
   ```

## 스택의 구현 방법

스택은 주로 두 가지 방법으로 구현됩니다:

### 1. 배열 기반 구현

배열을 사용하여 스택을 구현하는 방법은 가장 직관적이고 간단합니다.

**장점:**
- 구현이 간단하고 직관적
- 인덱스를 통한 빠른 접근
- 메모리 지역성(locality)이 좋아 캐시 효율성이 높음

**단점:**
- 고정된 크기를 갖기 때문에 스택 오버플로우 발생 가능
- 동적으로 크기를 조절하려면 추가 작업 필요
- 배열 크기를 미리 정해야 함

### 2. 연결 리스트 기반 구현

단일 연결 리스트를 사용하여 스택을 구현하는 방법입니다.

**장점:**
- 크기 제한이 없어 스택 오버플로우 걱정이 없음
- 동적으로 메모리를 할당하므로 메모리 낭비가 적음
- 필요에 따라 늘어나고 줄어듦

**단점:**
- 포인터를 위한 추가 메모리 필요
- 구현이 배열보다 약간 복잡함
- 메모리 할당/해제에 따른 오버헤드 발생 가능

## 스택의 활용 사례

스택은 다양한 분야에서 활용됩니다:

### 1. 프로그래밍 언어 및 컴파일러
- **함수 호출 관리 (콜 스택)**
  - 함수 호출 시 매개변수, 반환 주소, 지역 변수 등이 스택에 저장
  - 함수 종료 시 스택에서 제거되어 이전 실행 상태로 복귀
  - 재귀 함수의 호출 구조 관리

- **괄호 검사 및 구문 분석**
  - 컴파일러가 소스 코드의 괄호 짝이 맞는지 검사
  - 수식의 구문 분석 및 평가

### 2. 알고리즘과 자료구조
- **중위 표기법 → 후위 표기법 변환**
  - 연산자 우선순위를 처리하기 위해 스택 사용
  
- **그래프 알고리즘**
  - 깊이 우선 탐색(DFS)의 구현
  - 위상 정렬(Topological Sorting)
  - 강한 연결 요소(Strongly Connected Components) 찾기

- **백트래킹 알고리즘**
  - 미로 찾기, N-Queens 문제 등에서 이전 상태로 돌아가기

### 3. 시스템 및 애플리케이션 기능
- **웹 브라우저 히스토리**
  - 뒤로 가기, 앞으로 가기 기능 구현
  
- **실행 취소/다시 실행(Undo/Redo)**
  - 텍스트 편집기의 명령 기록 관리
  - 포토샵 등 그래픽 소프트웨어의 작업 이력

- **메모리 관리**
  - 프로그램의 스택 메모리 영역 관리
  - 함수 호출 프레임 스택

## 자바스크립트로 스택 구현

### 배열 기반 구현

```javascript
class Stack {
  constructor() {
    this.items = [];
  }
  
  // 스택에 요소 추가
  push(element) {
    this.items.push(element);
    return this; // 메서드 체이닝 지원
  }
  
  // 스택의 맨 위 요소 제거 및 반환
  pop() {
    if (this.isEmpty()) {
      return "스택이 비어있습니다";
    }
    return this.items.pop();
  }
  
  // 스택의 맨 위 요소 반환 (제거하지 않음)
  peek() {
    if (this.isEmpty()) {
      return "스택이 비어있습니다";
    }
    return this.items[this.items.length - 1];
  }
  
  // 스택이 비어있는지 확인
  isEmpty() {
    return this.items.length === 0;
  }
  
  // 스택의 크기 반환
  size() {
    return this.items.length;
  }
  
  // 스택 비우기
  clear() {
    this.items = [];
    return this;
  }
  
  // 스택의 모든 요소 출력
  print() {
    if (this.isEmpty()) {
      console.log("스택이 비어있습니다");
      return;
    }
    console.log("스택 내용 (bottom → top):", this.items.join(", "));
  }
}

// 사용 예시
const stack = new Stack();
stack.push(10).push(20).push(30);  // 메서드 체이닝
console.log("스택:", stack.items);        // [10, 20, 30]
console.log("맨 위 요소:", stack.peek());  // 30
console.log("팝:", stack.pop());          // 30
console.log("팝 후 스택:", stack.items);   // [10, 20]
console.log("스택 크기:", stack.size());   // 2
stack.print();                            // 스택 내용 (bottom → top): 10, 20
```

### 연결 리스트 기반 구현

```javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedListStack {
  constructor() {
    this.top = null;
    this.size = 0;
  }
  
  // 스택에 요소 추가
  push(data) {
    const newNode = new Node(data);
    
    if (this.isEmpty()) {
      this.top = newNode;
    } else {
      newNode.next = this.top;
      this.top = newNode;
    }
    
    this.size++;
    return this; // 메서드 체이닝 지원
  }
  
  // 스택의 맨 위 요소 제거 및 반환
  pop() {
    if (this.isEmpty()) {
      return "스택이 비어있습니다";
    }
    
    const removedNode = this.top;
    this.top = this.top.next;
    this.size--;
    
    return removedNode.data;
  }
  
  // 스택의 맨 위 요소 반환 (제거하지 않음)
  peek() {
    if (this.isEmpty()) {
      return "스택이 비어있습니다";
    }
    
    return this.top.data;
  }
  
  // 스택이 비어있는지 확인
  isEmpty() {
    return this.top === null;
  }
  
  // 스택의 크기 반환
  getSize() {
    return this.size;
  }
  
  // 스택 비우기
  clear() {
    this.top = null;
    this.size = 0;
    return this;
  }
  
  // 스택의 모든 요소 출력
  print() {
    if (this.isEmpty()) {
      console.log("스택이 비어있습니다");
      return;
    }
    
    let current = this.top;
    let stackValues = [];
    
    while (current) {
      stackValues.push(current.data);
      current = current.next;
    }
    
    console.log("스택 내용 (top → bottom):", stackValues.join(" → "));
  }
}

// 사용 예시
const linkedStack = new LinkedListStack();
linkedStack.push(10).push(20).push(30);  // 메서드 체이닝
console.log("맨 위 요소:", linkedStack.peek());      // 30
linkedStack.print();                                // 스택 내용 (top → bottom): 30 → 20 → 10
console.log("팝:", linkedStack.pop());              // 30
linkedStack.print();                                // 스택 내용 (top → bottom): 20 → 10
console.log("스택 크기:", linkedStack.getSize());    // 2
```

## 스택 관련 주요 알고리즘 문제

### 1. 괄호 짝 맞추기

괄호의 짝이 맞는지 확인하는 알고리즘은 스택의 대표적인 응용 사례입니다.

```javascript
function isValidParentheses(s) {
  const stack = [];
  const brackets = {
    '(': ')',
    '{': '}',
    '[': ']'
  };
  
  for (let char of s) {
    // 여는 괄호인 경우 스택에 추가
    if (brackets[char]) {
      stack.push(char);
    } 
    // 닫는 괄호인 경우
    else {
      // 스택이 비어있거나 짝이 맞지 않으면 실패
      if (stack.length === 0 || brackets[stack.pop()] !== char) {
        return false;
      }
    }
  }
  
  // 스택이 비어있어야 모든 괄호의 짝이 맞는 것
  return stack.length === 0;
}

// 테스트
console.log(isValidParentheses("()")); // true
console.log(isValidParentheses("()[]{}")); // true
console.log(isValidParentheses("(]")); // false
console.log(isValidParentheses("([)]")); // false
console.log(isValidParentheses("{[]}")); // true
```

### 2. 후위 표기법 변환 및 계산

중위 표기법(Infix)을 후위 표기법(Postfix)으로 변환하고 계산하는 알고리즘도 스택의 주요 응용 사례입니다.

```javascript
// 중위 표기법을 후위 표기법으로 변환
function infixToPostfix(infix) {
  const precedence = {
    '+': 1,
    '-': 1,
    '*': 2,
    '/': 2,
    '^': 3
  };
  
  const stack = [];
  let postfix = "";
  
  for (let char of infix) {
    // 공백은 무시
    if (char === ' ') continue;
    
    // 피연산자인 경우 출력
    if (/[0-9a-zA-Z]/.test(char)) {
      postfix += char;
    }
    // 여는 괄호는 스택에 푸시
    else if (char === '(') {
      stack.push(char);
    }
    // 닫는 괄호가 나오면 여는 괄호가 나올 때까지 스택에서 팝
    else if (char === ')') {
      while (stack.length > 0 && stack[stack.length - 1] !== '(') {
        postfix += stack.pop();
      }
      // 여는 괄호 제거
      stack.pop();
    }
    // 연산자인 경우
    else {
      // 스택의 top에 있는 연산자의 우선순위가 현재 연산자보다 높거나 같으면 팝
      while (
        stack.length > 0 &&
        stack[stack.length - 1] !== '(' &&
        precedence[stack[stack.length - 1]] >= precedence[char]
      ) {
        postfix += stack.pop();
      }
      // 현재 연산자를 스택에 푸시
      stack.push(char);
    }
  }
  
  // 스택에 남아 있는 모든 연산자를 출력
  while (stack.length > 0) {
    postfix += stack.pop();
  }
  
  return postfix;
}

// 후위 표기법 계산
function evaluatePostfix(postfix) {
  const stack = [];
  
  for (let char of postfix) {
    // 피연산자인 경우 스택에 푸시
    if (/[0-9]/.test(char)) {
      stack.push(parseInt(char, 10));
    }
    // 연산자인 경우 스택에서 두 개의 피연산자를 팝하여 계산
    else if (['+', '-', '*', '/'].includes(char)) {
      const b = stack.pop();
      const a = stack.pop();
      
      switch (char) {
        case '+': stack.push(a + b); break;
        case '-': stack.push(a - b); break;
        case '*': stack.push(a * b); break;
        case '/': stack.push(Math.floor(a / b)); break;
      }
    }
  }
  
  // 최종 결과는 스택의 유일한 요소
  return stack[0];
}

// 테스트
const infix = "3 + 4 * 2 / ( 1 - 5 ) ^ 2";
const postfix = infixToPostfix(infix);
console.log("중위 표기법:", infix);
console.log("후위 표기법:", postfix);

const simplePostfix = "34+5*";
console.log("후위 표기법 계산:", evaluatePostfix(simplePostfix)); // (3+4)*5 = 35
```

## 스택과 메모리

프로그래밍 언어에서 메모리는 주로 세 가지 영역으로 나뉩니다: 스택(Stack), 힙(Heap), 그리고 정적(Static) 영역입니다. 이 중 스택 메모리는 함수 호출과 지역 변수에 사용됩니다.

### 스택 메모리의 특징

1. **자동 메모리 관리**
   - 함수가 호출될 때 스택 프레임이 자동으로 생성됨
   - 함수가 종료될 때 스택 프레임이 자동으로 제거됨

2. **LIFO 구조**
   - 가장 최근에 호출된 함수가 가장 먼저 종료됨
   - 스택 최상단의 함수만 실행 중인 상태

3. **스택 프레임 구성**
   - 지역 변수
   - 매개변수
   - 반환 주소
   - 기타 함수 호출 정보

4. **스택 오버플로우**
   - 스택 메모리가 가득 차면 발생
   - 주로 무한 재귀 호출이나 대량의 로컬 변수 선언 시 발생

### 콜 스택 예제

```javascript
function multiply(a, b) {
  return a * b;
}

function square(n) {
  return multiply(n, n);
}

function printSquare(n) {
  const squared = square(n);
  console.log(squared);
}

printSquare(5);
```

위 코드의 실행 과정에서 콜 스택은 다음과 같이 변화합니다:

1. `printSquare(5)` 호출 → 스택에 `printSquare` 프레임 추가
2. `square(5)` 호출 → 스택에 `square` 프레임 추가
3. `multiply(5, 5)` 호출 → 스택에 `multiply` 프레임 추가
4. `multiply` 함수가 `25` 반환 → `multiply` 프레임 제거
5. `square` 함수가 `25` 반환 → `square` 프레임 제거
6. `console.log(25)` 실행 → `printSquare` 프레임 제거
7. 콜 스택이 비어있는 상태로 돌아옴

## 면접에서 자주 나오는 스택 관련 질문

1. **스택과 큐의 차이점은 무엇인가요?**
   - 스택: LIFO(Last-In-First-Out), 한쪽 끝에서만 삽입/삭제
   - 큐: FIFO(First-In-First-Out), 한쪽 끝에서 삽입, 다른 쪽 끝에서 삭제

2. **스택의 주요 응용 사례를 설명해주세요.**
   - 함수 호출(재귀 포함)
   - 괄호 검사
   - 후위 표기법 변환 및 계산
   - 웹 브라우저 방문 기록
   - 실행 취소(Undo) 기능

3. **스택을 두 개 사용하여 큐를 구현하는 방법을 설명해주세요.**
   - 첫 번째 스택(s1)은 삽입 연산에 사용
   - 두 번째 스택(s2)은 삭제 연산에 사용
   - enqueue: s1에 요소 추가
   - dequeue: s2가 비어있으면 s1의 모든 요소를 s2로 옮긴 후, s2에서 pop

4. **배열과 연결 리스트로 구현한 스택의 장단점은 무엇인가요?**
   - 배열: 구현이 간단하지만 크기 제한, 동적 확장 시 오버헤드
   - 연결 리스트: 크기 제한 없지만 포인터 저장을 위한 추가 메모리 필요

5. **스택 오버플로우가 발생하는 상황과 해결 방법은 무엇인가요?**
   - 발생 상황: 무한 재귀, 너무 많은 함수 호출, 대량의 지역 변수
   - 해결 방법: 재귀를 반복문으로 변경, 꼬리 재귀 최적화, 스택 크기 증가

6. **O(1) 시간 복잡도로 최솟값을 찾을 수 있는 스택을 설계하는 방법은?**
   - 기본 스택과 최솟값을 추적하는 보조 스택을 함께 사용
   - 요소가 추가될 때마다 현재 최솟값을 보조 스택에 저장
   - 요소가 제거될 때마다 보조 스택에서도 제거
   
---