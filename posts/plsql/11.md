# 🟡 PL/SQL - (4)
## 커서 FOR 루프
- 명시적 커서를 처리하기 위한 단축 방법
- OPEN, FETCH, CLOSE가 암시적으로 발생
- 레코드가 암시적으로 선언됨

```SQL
DECLARE
    -- 1) 커서 정의
    CURSOR 커서명 IS
        SELECT문;
BEGIN
    -- 2) 커서 실행
    -- 3) 데이터 확인 및 반환
    FOR 레코드명 IN 커서명 LOOP
        -- 데이터가 존재하는 경우에만 실행
        -- 명시적 커서의 속성에 접근 가능
    END LOOP; -- 4) 커서 종료
END;
/
```
- 예시
```SQL
DECLARE
    -- 커서 정의
    CURSOR emp_cursor IS
        SELECT employee_id, last_name, hire_date
        FROM employees
        WHERE department_id = 50;

BEGIN
    FOR emp_rec IN emp_cursor LOOP -- 암묵적으로 OPEN과 FETCH 실행
        DBMS_OUTPUT.PUT_LINE(emp_cursor%ROWCOUNT || ': ' || emp_rec.employee_id || ', ' || emp_rec.last_name || ', ' || emp_rec.hire_date);
    END LOOP; -- 암묵적으로 CLOSE 실행
    -- 커서 FOR LOOP 바깥에선 %ISOPEN 제외 접근 불가.
    -- DBMS_OUTPUT.PUT_LINE(emp_cursor%ROWCOUNT);
END;
/
```
```
[output]
1: 124, Mourgos, 16/11/17
2: 141, Rajs, 17/10/13
3: 142, Davies, 29/01/15
4: 143, Matos, 15/03/16
5: 144, Vargas, 09/07/16
6: 113, Popp, 06/03/25
```

## 예외 처리
- 예외사항이 발생 시 종료하지 않고 작업을 계속 수행하도록 하는 기능
- **예외사항**: 블록 실행 중 발생하는 PL/SQL의 식별자. 보통 예외 발생시 실행 종료됨.
- 프로그램 실행 중 발생할 수 있는 오류를 감지하고 적절히 처리하여 시스템의 안정성과 보안성을 유지
- 데이터 손실, 무한 루프, 보안 취약점 등 방지
```sql
DECLARE -- 선언부

BEGIN -- 실행

EXCEPTION -- 예외처리
    WHEN 예외이름1 THEN
        예외 발생 시 실행 코드;
    WHEN 예외이름2 OR 예외이름3 THEN
        예외2 또는 예외3 발생 시 실행 코드;
    WHEN OTHERS THEN
        위에 선언되지 않은 예외 발생 시 실행 코드;
END;
/
```
- 예시)
```sql
DECLARE 
    v_ename employees.last_name%TYPE;
BEGIN
    SELECT last_name
    INTO v_ename
    FROM employees
    WHERE employee_id = -1;
    
    DBMS_OUTPUT.PUT_LINE(v_ename);

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('사원이 없습니다.');
END;
/
```
```
[output]
사원이 없습니다.
```

### 예외 유형
- 미리 정의되어 있고 이름도 존재하는 예외
```sql
DECLARE 
    v_ename employees.last_name%TYPE;
BEGIN
    SELECT last_name
    INTO v_ename
    FROM employees
    WHERE department_id = &부서번호; 
    -- 부서번호 50: TOO_MANY_ROWS / ORA-01422
    -- 부서번호 1000: NO_DATA_FOUND / ORA-01403
    
    DBMS_OUTPUT.PUT_LINE(v_ename);

EXCEPTION
    WHEN TOO_MANY_ROWS THEN
        DBMS_OUTPUT.PUT_LINE('여러 행이 반환되었습니다.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('기타 예외가 발생했습니다.');

END;
/
```
- 미리 정의되어 있지만 이름은 없는 예외
```SQL
DECLARE
    -- 예외이름 선언
    e_emps_remaining EXCEPTION;
    
    -- 예외이름과 에러코드 연결
    PRAGMA EXCEPTION_INIT(e_emps_remaining, -02292);
BEGIN
    DELETE FROM departments
    WHERE department_id = &부서번호;
EXCEPTION
    WHEN e_emps_remaining THEN
        DBMS_OUTPUT.PUT_LINE('참조 중인 데이터가 있습니다.');
END;
/
```

- 사용자 정의 예외
```SQL
DECLARE
    -- 예외 이름 선언
    e_dept_del_fail EXCEPTION;
BEGIN
    DELETE FROM departments
    WHERE department_id = 0;

    -- 예외가 되는 상황 지정
    IF SQL%ROWCOUNT = 0 THEN
        RAISE e_dept_del_fail;
    END IF;
    DBMS_OUTPUT.PUT_LINE('정상적으로 삭제되었습니다.');
EXCEPTION
    WHEN e_dept_del_fail THEN
        DBMS_OUTPUT.PUT_LINE('해당 부서는 존재하지 않습니다.');
        DBMS_OUTPUT.PUT_LINE('부서번호를 확인해주세요.');
END;
/
```

- 사용자 정의 예외 vs 조건문 처리
- 해당 경우에 더 이상 코드가 진행되면 안 될 때는 예외처리 권장

### 예외 트랩 함수
- SQLCODE : 오류 코드의 숫자 값 반환
- SQLERRM : 오류 번호와 연관된 메시지 반환
